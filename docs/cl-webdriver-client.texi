\input texinfo   @c -*-texinfo-*-
@comment $Id@w{$}
@comment %**start of header
@settitle Common Lisp Webdriver Client
@syncodeindex pg cp
@setfilename cl-webdriver-client.info
@comment %**end of header
@include common-lisp.texi

@dircategory Common Lisp
@direntry
* cl-webdriver-client: (cl-webdriver-client)Common Lisp Webdriver Client.
@end direntry

@titlepage
@title Common Lisp Webdriver Client

@author A.U. Thor <@email{bug-sample@@gnu.org}>
@page
@vskip 0pt plus 1filll
@end titlepage

@contents

@node Top
@top Top
@cindex cl-webdriver-client
@cindex cl-webdriver-client

CL Webdriver Client is a binding library to the Selenium 4.0 that implements the @url{https://www.w3.org/TR/webdriver, W3C Webdriver spec}.

@menu
* Introduction::
* Usage::
* Installation::
* Utils::
* API::
* Index::
@end menu


@node Introduction
@chapter Introduction

Common Lisp Webdriver Client is a binding library to the Selenium 4.0 that implements the @url{https://www.w3.org/TR/webdriver, W3C Webdriver spec}.

This software is in development. The APIs will be likely to change.

@node Usage
@chapter Usage

@menu
* Actions::
@end menu

@lisp
;; see examples/*.lisp and t/*.lisp
(in-package :cl-user)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (ql:quickload :cl-webdriver-client))

(defpackage go-test
  (:use :cl :webdriver-client))

(in-package :go-test)

(defparameter *code* "
package main
import \"fmt\"

func main() @{
    fmt.Print(\"Hello WebDriver!\")
@}")

(with-session ()
  (setf (url) "http://play.golang.org/?simple=1")
  (let ((elem (find-element "#code" :by :css-selector)))
    (element-clear elem)
    (element-send-keys elem *code*))
  (let ((btn (find-element "#run")))
    (element-click btn))

  (loop
     with div = (find-element "#output")
     for ouput = (element-text div)
     while (equal ouput "Waiting for remote server...")
     do (sleep 0.1)
     finally (print ouput)))
@end lisp

@node Actions
@section Actions

The Actions API provides a low-level interface for providing virtualised device input to the web browser. Conceptually, the Actions commands divide time into a series of ticks. The local end sends a series of actions which correspond to the change in state, if any, of each input device during each tick. For example, pressing a key is represented by an action sequence consisting of a single key input device and two ticks, the first containing a keyDown action, and the second a keyUp action, whereas a pinch-zoom input is represented by an action sequence consisting of three ticks and two pointer input devices of type touch, each performing a sequence of actions pointerDown, followed by pointerMove, and then pointerUp.

See @url{https://www.w3.org/TR/webdriver/#actions} for the whole explanation.

To perform actions in @emph{cl-webdriver-client} use @clref{WEBDRIVER-CLIENT, PERFORM-ACTIONS, function}. That function implements a little language, with the following syntax:

@subheading Syntax:

@verbatim
actions ::= ({actions-input-source}*)
actions-input-source ::= (input-source-type {action}*)
input-source-type ::= :none | :pointer | :mouse | :pen | :touch | :key
action ::= pause | pointer-move | pointer-down | pointer-up | key-down | key-up
pause ::= (:pause duration)
pointer-move ::= (:pointer-move x y)
pointer-down ::= (:pointer-down button-number)
pointer-up ::= (:pointer-up button-number)
key-down ::= (:key-down key)
key-up ::= (:key-up key)
@end verbatim

@subheading Arguments and values:

@itemize
@item @emph{actions}---a list of actions-input-sources. One list for each type of input source that wants to be used.
@item @emph{actions-input-source}---a list. Specifies the list of actions to perform for a particular input source.
@item @emph{duration}---an integer. The time to pause in milliseconds.
@item @emph{key}---a string. A string with the character (e.g. ``a''). Use @clref{WEBDRIVER-CLIENT, KEY, function} for entering special characters.
@item @emph{button-number}---an integer greater than or equal to 0.
@item @emph{x}---an integer. Horizontal screen coordinate.
@item @emph{y}---an integer. Vertical screen coordinate.
@end itemize

@subheading Examples:

@lisp
(perform-actions `((:pen
		     (:pointer-move 22 33)
		     (:pause 2000)
		     (:pointer-move 23 54))))
@end lisp

@node Installation
@chapter Installation

@example
git clone https://github.com/TatriX/cl-webdriver-client ~/quicklisp/local-projects/
(ql:quickload :cl-webdriver-client)
@end example

You need a running instance of selenium-server-standalone.

[Download](http://www.seleniumhq.org/download/) it and run:

@example
curl -L0 https://goo.gl/SP94ZB -o selenium-server-standalone.jar
java -jar selenium-server-standalone.jar
@end example

@node Utils
@chapter Utils

There is a @code{:webdriver-client-utils} package which should reduce boilerplate. For example:

@lisp
(defpackage my-test
  (:use :cl :webdriver-client)
  (:import-from :webdriver-client-utils
                :send-keys
                :click
                :wait-for
                :classlist))

(in-package :my-test)

(with-session ()
  (setf (url) "http://google.com")
  (send-keys "cl-webdriver-client")
  (click "[name=btnK]")
  (wait-for "#resultStats"))

@end lisp

@node Interactive session
@section Interactive session

You can just start the session and control it from your repl:

@lisp
(in-package :my-test)

(start-interactive-session)

(setf (url) "http://google.com")
(send-keys "cl-webdriver-client")
(send-keys (key :enter))
(classlist "#slim_appbar") ; prints ("ab_tnav_wrp")

(stop-interactive-session)
@end lisp

@node Utils API conventions
@section Utils API conventions

If utility function needs an element to work on it defaults to `(active-element)`.
@lisp
(click) ; click on the current active element.
@end lisp

You can also pass a css selector as a last parameter.

@lisp
(print (id "#submit")) ; print id the of matched element

(assert (= (first (classlist "div")) "first-div-ever"))
@end lisp

To change default element you can:

@lisp
(setf webdriver-client-utils:*default-element-func* (lambda () (find-element "input[type=submit]"))
@end lisp

@node Waiting for the reaction
@section Waiting for the reaction

Often you need to wait for some action to be done. For example if you
do a @code{(click)} on the button to load search results, you need to wait
them to load.

@lisp
(wait-for ".search-result" :timeout 10) ; wait 10 seconds
@end lisp

Timeout defaults to 30 seconds. You can globally change it:
@lisp
(setf webdriver-client-utils:*timeout* 3)
@end lisp

@node Running tests
@section Running tests

@heading REPL

@lisp
(ql:quickload '(:cl-selenium :prove))
(setf prove:*enable-colors* nil)
(prove:run :cl-selenium-test)
@end lisp

@heading Shell

@example
sh
./test.sh
@end example

@node API
@chapter API

@node WEBDRIVER-CLIENT package
@section WEBDRIVER-CLIENT package

(@clpackage :webdriver-client-client :include-external-definitions t :categorized :by-docstring-category)

@node WEBDRIVER-CLIENT-UTILS package
@section WEBDRIVER-CLIENT-UTILS package

(@clpackage :webdriver-client-utils :include-external-definitions t)

@node Index
@chapter Index

@printindex cp
@printindex vr
@printindex fn

@bye
